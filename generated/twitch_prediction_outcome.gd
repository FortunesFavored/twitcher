@tool
extends RefCounted

# CLASS GOT AUTOGENERATED DON'T CHANGE MANUALLY. CHANGES CAN BE OVERWRITTEN EASILY.

class_name TwitchPredictionOutcome

## An ID that identifies this outcome.
var id: String;
## The outcomeâ€™s text.
var title: String;
## The number of unique viewers that chose this outcome.
var users: int;
## The number of Channel Points spent by viewers on this outcome.
var channel_points: int;
## A list of viewers who were the top predictors; otherwise, **null** if none.
var top_predictors: Array[TopPredictors];
## The color that visually identifies this outcome in the UX. Possible values are:      * BLUE * PINK    If the number of outcomes is two, the color is BLUE for the first outcome and PINK for the second outcome. If there are more than two outcomes, the color is BLUE for all outcomes.
var color: String;

static func from_json(d: Dictionary) -> TwitchPredictionOutcome:
	var result = TwitchPredictionOutcome.new();
	if d.has("id") && d["id"] != null:
		result.id = d["id"];
	if d.has("title") && d["title"] != null:
		result.title = d["title"];
	if d.has("users") && d["users"] != null:
		result.users = d["users"];
	if d.has("channel_points") && d["channel_points"] != null:
		result.channel_points = d["channel_points"];
	if d.has("top_predictors") && d["top_predictors"] != null:
		for value in d["top_predictors"]:
			result.top_predictors.append(TopPredictors.from_json(value));
	if d.has("color") && d["color"] != null:
		result.color = d["color"];
	return result;

func to_dict() -> Dictionary:
	var d: Dictionary = {};
	d["id"] = id;
	d["title"] = title;
	d["users"] = users;
	d["channel_points"] = channel_points;
	d["top_predictors"] = [];
	if top_predictors != null:
		for value in top_predictors:
			d["top_predictors"].append(value.to_dict());
	d["color"] = color;
	return d;

func to_json() -> String:
	return JSON.stringify(to_dict());

## 
class TopPredictors extends RefCounted:
{for properties as property}
	## {property.description}
	var {property.field_name}: {property.type};
{/for}


	static func from_json(d: Dictionary) -> TopPredictors:
		var result = TopPredictors.new();
{for properties as property}
{if property.is_property_array}
		if d.has("{property.property_name}") && d["{property.property_name}"] != null:
			for value in d["{property.property_name}"]:
				result.{property.field_name}.append(value);
{/if}
{if property.is_property_typed_array}
		if d.has("{property.property_name}") && d["{property.property_name}"] != null:
			for value in d["{property.property_name}"]:
				result.{property.field_name}.append({property.array_type}.from_json(value));
{/if}
{if property.is_property_sub_class}
		if d.has("{property.property_name}") && d["{property.property_name}"] != null:
			result.{property.field_name} = {property.type}.from_json(d["{property.property_name}"]);
{/if}
{if property.is_property_basic}
		if d.has("{property.property_name}") && d["{property.property_name}"] != null:
			result.{property.field_name} = d["{property.property_name}"];
{/if}
{/for}
		return result;

	func to_dict() -> Dictionary:
		var d: Dictionary = {};
{for properties as property}
{if property.is_property_array}
		d["{property.property_name}"] = [];
		if {property.field_name} != null:
			for value in {property.field_name}:
				d["{property.property_name}"].append(value);
{/if}
{if property.is_property_typed_array}
		d["{property.property_name}"] = [];
		if {property.field_name} != null:
			for value in {property.field_name}:
				d["{property.property_name}"].append(value.to_dict());
{/if}
{if property.is_property_sub_class}
		if {property.field_name} != null:
			d["{property.property_name}"] = {property.field_name}.to_dict();
{/if}
{if property.is_property_basic}
		d["{property.property_name}"] = {property.field_name};
{/if}
{/for}
		return d;


	func to_json() -> String:
		return JSON.stringify(to_dict());

